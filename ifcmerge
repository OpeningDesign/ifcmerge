#!/usr/bin/perl

use strict;
use warnings;
use DateTime;
use DateTime::TimeZone;
use 5.010;

die "Usage: $0 base.ifc local.ifc remote.ifc merged.ifc" unless scalar(@ARGV) == 4;

my $base = Ifc->new;
$base->load($ARGV[0]);
my $local = Ifc->new;
$local->load($ARGV[1]);
my $remote = Ifc->new;
$remote->load($ARGV[2]);
my $merged = Ifc->new;
$merged->load($ARGV[0]); # note: initially the same as base

$local->compare($base);
$remote->compare($base);

# if both files have added entities, renumber local added entities to make space

my $offset = $remote->last - $base->last;
my $max = $base->last;
if ($offset > 0)
{
    for my $id (reverse ($local->added_ids))
    {
        my $text = $local->{file}->{$id};
        $text =~ s/#([0-9]*)/'#'. _add_offset($1, $max, $offset)/ge;
        $local->{file}->{_add_offset($id, $max, $offset)} = $text;
        delete $local->{file}->{$id};
    }
    for my $id ($local->modified_ids)
    {
        my $text = $local->{file}->{$id};
        $text =~ s/#([0-9]*)/'#'. _add_offset($1, $max, $offset)/ge;
        $local->{file}->{$id} = $text;
    }
}

sub _add_offset
{
    my ($id, $max, $offset) = @_;
    return $id + $offset if $id > $max;
    return $id;
}

$local->compare($base); # local may have been renumbered

# copy added entities

for my $id ($local->added_ids)
{
    $merged->{file}->{$id} = $local->{file}->{$id};
}
for my $id ($remote->added_ids)
{
    $merged->{file}->{$id} = $remote->{file}->{$id};
}

# delete deleted entities

for my $id ($local->deleted_ids)
{
    if (defined $remote->{modified}->{$id})
    {
        die "local deleted entity #$id modified in remote! bailing out";
    }
    else
    {
        delete $merged->{file}->{$id};
    }
}
for my $id ($remote->deleted_ids)
{
    if (defined $local->{modified}->{$id})
    {
        die "remote deleted entity #$id modified in local! bailing out";
    }
    else
    {
        delete $merged->{file}->{$id};
    }
}

# update modified entities
# TODO if entity is modified in both, try and merge attributes

for my $id ($local->modified_ids)
{
    $merged->{file}->{$id} = $local->{file}->{$id};
}
for my $id ($remote->modified_ids)
{
    if (defined $local->{modified}->{$id})
    {
        warn "entity #$id modified in both! using remote version";
    }
    $merged->{file}->{$id} = $remote->{file}->{$id};
}

# success

$merged->write($ARGV[3]);

0;

package Ifc;

sub new
{
    my $class = shift;
    my $self = {headers => [], file => {}, added => {}, deleted => {}, modified => {}};
    bless $self, $class;
    return $self;
}

sub load
{
    my $self = shift;
    my $path = shift;
    open my $IN, '<', $path or die "$!";
    for my $line (<$IN>)
    {
        if ($line =~ /^#([0-9]+)=(.*);/)
        {
            $self->{file}->{$1} = $2;
        }
        elsif ($line =~ /\/\*.*\*\//)
        {
            # we discard comments
        }
        else
        {
            push @{$self->{headers}}, $line;
        }
    }
    close $IN;
}

sub write
{
    my $self = shift;
    my $path = shift;
    my $dt = DateTime->now;
    my $tz = DateTime::TimeZone->new(name => 'local');
    my $tz_offset = $tz->offset_as_string($tz->offset_for_datetime($dt));
    $tz_offset =~ s/(..)(..)$/$1:$2/;
    my $now = $dt.$tz_offset;
    open my $OUT, '>', $path or die "$!";
    for my $line (@{$self->{headers}})
    {
        if ($line =~ /^FILE_NAME/)
        {
            $line =~ s/....-..-..T..:..:..[+-]..:../$now/;
        }
        print $OUT $line;
        if ($line =~ /^DATA;/)
        {
            for my $id ($self->file_ids)
            {
                say $OUT "#$id=". $self->{file}->{$id} .";";
            }
        }
    }
}

sub compare
{
    my ($self, $other) = @_;
    $self->{added} = {};
    $self->{modified} = {};
    $self->{deleted} = {};
    for my $id ($self->file_ids)
    {
        if (not defined $other->{file}->{$id})
        {
            $self->{added}->{$id} = 1;
        }
        elsif ($self->{file}->{$id} ne $other->{file}->{$id})
        {
            $self->{modified}->{$id} = 1;
        }
    }
    for my $id ($other->file_ids)
    {
        if (not defined $self->{file}->{$id})
        {
            $self->{deleted}->{$id} = 1;
        }
    }
}

sub last
{
    my $self = shift;
    my @sorted = sort {$a <=> $b} $self->file_ids;
    return $sorted[-1];
}

sub file_ids
{
    my $self = shift;
    return sort {$a <=> $b} keys %{$self->{file}};
}

sub added_ids
{
    my $self = shift;
    return sort {$a <=> $b} keys %{$self->{added}};
}

sub modified_ids
{
    my $self = shift;
    return sort {$a <=> $b} keys %{$self->{modified}};
}

sub deleted_ids
{
    my $self = shift;
    return sort {$a <=> $b} keys %{$self->{deleted}};
}
